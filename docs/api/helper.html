<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>server.api.helper API documentation</title>
<meta name="description" content="Helper module containing functions used by different modules" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>server.api.helper</code></h1>
</header>
<section id="section-intro">
<p>Helper module containing functions used by different modules</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Helper module containing functions used by different modules&#34;&#34;&#34;
from collections.abc import Callable
from flask_restful import abort
from functools import wraps
from glob import iglob
import numpy as np
from os import path, environ
from PIL import Image
from time import time
from typing import Any, Union, NoReturn, Literal, Tuple

if __name__ == &#34;__main__&#34;:
    exit(&#34;Start via run.py!&#34;)


# See https://stackoverflow.com/a/27737385
def timing(f: &#39;Callable[[Any], Any]&#39;) -&gt; &#39;Callable[[Any, Any], Any]&#39;:
    &#34;&#34;&#34;Method times the execution of a function, shall be used as a decorator

    Returns:
        f: wrapper function
    &#34;&#34;&#34;
    @wraps(f)
    def wrap(*args, **kw) -&gt; Any:
        ts = time()
        result = f(*args, **kw)
        te = time()
        print(f&#34;func:{f.__name__} args:[{args}, {kw}] took: {te-ts:2.4f} sec&#34;)
        return result
    return wrap

# Allowed extensions for uploaded images
ALLOWED_EXTENSIONS = { &#34;png&#34;, &#34;jpg&#34;, &#34;jpeg&#34; }

def allowed_file(filename: str) -&gt; bool:
    &#34;&#34;&#34;Checks if the file is valid. A dot (.) needs to be in the filename and the extension needs to be present in ALLOWED_EXTENSIONS

    Args:
        filename (str): filename to be assessed

    Returns:
        bool: True if filename is allowed, False if not
    &#34;&#34;&#34;
    return &#39;.&#39; in filename and filename.rsplit(&#39;.&#39;, 1)[1].lower() in ALLOWED_EXTENSIONS

def abort_if_pictures_dont_exist(picture_ids: &#39;list[int]&#39;, db: Any) -&gt; &#39;Union[None, NoReturn]&#39;:
    &#34;&#34;&#34;Terminates request, if given picture_id(s) is/are not present within the database
    
    Args:
        picture_ids (list[int]): ids of pictures to be assessed
        db (server.api.db.Database): instance of the database
    &#34;&#34;&#34;
    success, possible_missing_ids = db.are_all_ids_in_database(picture_ids)
    if not success:
        print(f&#34;Image(s) with id(s) {possible_missing_ids} is/are not in the database!&#34;)
        abort(404, message=f&#34;Picture(s) {possible_missing_ids} not found&#34;)

def is_k_valid(k: Any, db: Any, id_from_database: bool=False) -&gt; &#39;Union[Tuple[Literal[True], None, int], Tuple[Literal[False], str, Union[int, None]]]&#39;:
    &#34;&#34;&#34;Checks if a given value for k, k being amount of nearest neighbours to search in a faiss index, is valid.

    Args:
        k (Any): amount of desired nearest neighbours. Will be casted as an int, fails if an error occures
        db (server.api.db.Database): instance of the database
        id_from_database (bool): if True, the image to be searched for is already in the database, need to have 0 &lt; k &lt; db.count_documents_in_collection() - 1, 
        False if different image, need to have 0 &lt; k &lt; db.count_documents_in_collection()

    Returns:
        bool: True if successful, False if an error occured
        Union[None, str]: None if successful, str containing the error message if an error occured
        int: the (possibly casted) int value for k
    &#34;&#34;&#34;
    if k is None:
        return False, &#34;k is None&#34;, k
    if not type(k) is int:
        try:
            k = int(k)
        except ValueError as e:
            abort(500, message=e)
    if k &lt; 1:
        return False, f&#34;{k} &lt; 1, value too small&#34;, k
    nr_of_files_in_database = db.count_documents_in_collection()
    if id_from_database:
        nr_of_files_in_database -= 1 # excluding the file itself
    if k &gt; nr_of_files_in_database:
        return False, f&#34;k {k} is bigger than the (other) {nr_of_files_in_database} images in the index!&#34;, k
    return True, None, k

def process_image(file_path: str) -&gt; &#39;Tuple[np.ndarray, Tuple[int, int]]&#39;:
    &#34;&#34;&#34;Convert an image indicated by its file_path to a flat np.ndarray

    Args:
        file_path (str): the path of the image

    Returns:
        np.ndarray: the flat image
        [int, int]: width, height of the original image
    &#34;&#34;&#34;
    with Image.open(file_path) as img:
        image_shape = (img.width, img.height)
        converted_image = img.convert(&#34;RGB&#34;)
    resized_image = np.array(converted_image, dtype=&#34;float32&#34;).ravel()
    return resized_image, image_shape

def _load_images(the_path: str) -&gt; &#39;Union[Tuple[np.ndarray, np.ndarray, Literal[True], Tuple[int, int]], Tuple[None, None, Literal[False], None]]&#39;:
    &#34;&#34;&#34;Functions loads all images within the_path directory

    Args:
        the_path (str): path to the directory containing the images

    Returns:
        np.ndarray: array of the filenames or None if an error occured
        np.ndarray: array containing the flat images or None if an error occured
        bool: True if successful, False if an error occured
        [int, int]: width, height of all images or None if an error occured
    &#34;&#34;&#34;
    if not path.isdir(the_path):
        return None, None, False, None
    filename_list = []
    image_list = []
    correct_shape = None
    for image in iglob(path.join(the_path, &#34;*&#34;)):
        filename = path.split(image)[-1]
        resized_image, image_shape = process_image(image)
        # Check if image shape is correct
        if correct_shape is None:
            correct_shape = image_shape
        elif correct_shape != image_shape:
            return None, None, False, None
        filename_list.append(filename)
        image_list.append(resized_image)
    names = np.array(filename_list)
    images = np.array(image_list, dtype=&#34;float32&#34;)
    return names, images, True, correct_shape

def load_images(the_path: str) -&gt; &#39;Tuple[Union[np.ndarray, None], Union[np.ndarray, None], Literal[True]]&#39;:
    &#34;&#34;&#34;Call this function with a the_path to a directory containing images

    Args:
        the_path (str): path to the directory containing the images

    Returns:
        np.ndarray: array of the filenames or None if an error occured
        np.ndarray: array containing the flat images or None if an error occured
        bool: True if successful, False if an error occured
    &#34;&#34;&#34;
    names, images, success, correct_shape = _load_images(the_path)
    if success and correct_shape is not None:
        environ[&#34;FULLSIZE_WIDTH&#34;] = str(correct_shape[0])
        environ[&#34;FULLSIZE_HEIGHT&#34;] = str(correct_shape[1])
        return names, images, True
    else:
        return None, None, False

def load_images_by_id(ids: &#39;list[int]&#39;, db: Any) -&gt; &#39;Union[Tuple[Literal[True], np.ndarray, list[dict], None], Tuple[Literal[False], None, None, str]]&#39;:
    &#34;&#34;&#34;Reload all images indicated by ids by getting the path from db

    Args:
        ids (list[int]): list containing the ids of the images within the database, prechecked
        db (server.api.db.Database): instance of the database

    Returns:
        bool: True if successful, False if an error occured
        np.ndarray: flat images or None if an error occured
        list[dict]: list containing the metadata of the loaded images
        Union[None, str]: None if successful, str containing the error message if an error occured
    &#34;&#34;&#34;
    images = db.get_multiple_by_id(ids, None)
    if images is None:
        return False, None, None, &#34;Error retrieving images from database&#34;
    p_images = []
    all_images = []
    for image in images:
        p_image, _ = process_image(image[&#34;path&#34;])
        p_images.append(p_image)
        all_images.append({
            &#34;id&#34;: image[&#34;id&#34;],
            &#34;filename&#34;: image[&#34;filename&#34;],
            &#34;position&#34;: {
                &#34;x&#34;: image[&#34;x&#34;],
                &#34;y&#34;: image[&#34;y&#34;]
            },
            &#34;cluster_center&#34;: image[&#34;cluster_center&#34;]
        })
    p_images = np.array(p_images, dtype=&#34;float32&#34;)
    return True, p_images, all_images, None

def load_and_process_one_from_dataset(the_path: str) -&gt; np.ndarray:
    &#34;&#34;&#34;Loads the image indicated by the_path and converts it to a flat array

    Args:
        the_path (str): path to the image

    Returns:
        np.ndarray: the flat image as an array
    &#34;&#34;&#34;
    full_path = path.join(environ.get(&#34;DATA_PATH&#34;), the_path)
    resized_image, _ = process_image(full_path)
    return np.array(resized_image, dtype=&#34;float32&#34;)

analysed_dataset = None

def get_analysed_dataset() -&gt; &#39;Union[dict, None]&#39;:
    &#34;&#34;&#34;Return the values calulated for the dataset

    Returns:
       Union[dict, None]: dict containing the values, if anaylse_dataset has been called, None otherwise
    &#34;&#34;&#34;
    global analysed_dataset
    return analysed_dataset

def analyse_dataset(images: np.ndarray, coordinates: np.ndarray) -&gt; dict:
    &#34;&#34;&#34;Calculate the min, max and average coordinates. Return them and the amount of images and the width, height of thumbnails and fullsize images

    Args:
        images (np.ndarray): array containing all flat images
        coordinates (np.ndarray): array containing all coordinates calculated for images

    Returns:
        dict: contains the min, max and average coordinates, amount of images and width, height of images
    &#34;&#34;&#34;
    coord_min = np.amin(coordinates, axis=0)
    x_min = coord_min[0]
    y_min = coord_min[1]
    coord_max = np.amax(coordinates, axis=0)
    x_max = coord_max[0]
    y_max = coord_max[1]
    coord_average = np.sum(coordinates, axis=0) / coordinates.shape[0]
    x_average = coord_average[0]
    y_average = coord_average[1]
    global analysed_dataset; analysed_dataset = {
        &#34;coordinates&#34;: {
            &#34;min_x&#34;: x_min,
            &#34;max_x&#34;: x_max,
            &#34;min_y&#34;: y_min,
            &#34;max_y&#34;: y_max,
            &#34;average_x&#34;: x_average,
            &#34;average_y&#34;: y_average
        },
        &#34;images&#34;: {
            &#34;amount_of_images&#34;: images.shape[0],
            &#34;image_size&#34;: {
                &#34;width&#34;: environ.get(&#34;FULLSIZE_WIDTH&#34;),
                &#34;height&#34;: environ.get(&#34;FULLSIZE_HEIGHT&#34;)
            },
            &#34;thumbnail_size&#34;: {
                &#34;width&#34;: environ.get(&#34;ACTUAL_THUMBNAIL_WIDTH&#34;),
                &#34;height&#34;: environ.get(&#34;ACTUAL_THUMBNAIL_HEIGHT&#34;)
            },    
        }
    }
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="server.api.helper.abort_if_pictures_dont_exist"><code class="name flex">
<span>def <span class="ident">abort_if_pictures_dont_exist</span></span>(<span>picture_ids: list[int], db: Any) ‑> Union[None, NoReturn]</span>
</code></dt>
<dd>
<div class="desc"><p>Terminates request, if given picture_id(s) is/are not present within the database</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>picture_ids</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>ids of pictures to be assessed</dd>
<dt><strong><code>db</code></strong> :&ensp;<code><a title="server.api.db.Database" href="db.html#server.api.db.Database">Database</a></code></dt>
<dd>instance of the database</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abort_if_pictures_dont_exist(picture_ids: &#39;list[int]&#39;, db: Any) -&gt; &#39;Union[None, NoReturn]&#39;:
    &#34;&#34;&#34;Terminates request, if given picture_id(s) is/are not present within the database
    
    Args:
        picture_ids (list[int]): ids of pictures to be assessed
        db (server.api.db.Database): instance of the database
    &#34;&#34;&#34;
    success, possible_missing_ids = db.are_all_ids_in_database(picture_ids)
    if not success:
        print(f&#34;Image(s) with id(s) {possible_missing_ids} is/are not in the database!&#34;)
        abort(404, message=f&#34;Picture(s) {possible_missing_ids} not found&#34;)</code></pre>
</details>
</dd>
<dt id="server.api.helper.allowed_file"><code class="name flex">
<span>def <span class="ident">allowed_file</span></span>(<span>filename: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the file is valid. A dot (.) needs to be in the filename and the extension needs to be present in ALLOWED_EXTENSIONS</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename to be assessed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if filename is allowed, False if not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allowed_file(filename: str) -&gt; bool:
    &#34;&#34;&#34;Checks if the file is valid. A dot (.) needs to be in the filename and the extension needs to be present in ALLOWED_EXTENSIONS

    Args:
        filename (str): filename to be assessed

    Returns:
        bool: True if filename is allowed, False if not
    &#34;&#34;&#34;
    return &#39;.&#39; in filename and filename.rsplit(&#39;.&#39;, 1)[1].lower() in ALLOWED_EXTENSIONS</code></pre>
</details>
</dd>
<dt id="server.api.helper.analyse_dataset"><code class="name flex">
<span>def <span class="ident">analyse_dataset</span></span>(<span>images: numpy.ndarray, coordinates: numpy.ndarray) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the min, max and average coordinates. Return them and the amount of images and the width, height of thumbnails and fullsize images</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>array containing all flat images</dd>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>array containing all coordinates calculated for images</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>contains the min, max and average coordinates, amount of images and width, height of images</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyse_dataset(images: np.ndarray, coordinates: np.ndarray) -&gt; dict:
    &#34;&#34;&#34;Calculate the min, max and average coordinates. Return them and the amount of images and the width, height of thumbnails and fullsize images

    Args:
        images (np.ndarray): array containing all flat images
        coordinates (np.ndarray): array containing all coordinates calculated for images

    Returns:
        dict: contains the min, max and average coordinates, amount of images and width, height of images
    &#34;&#34;&#34;
    coord_min = np.amin(coordinates, axis=0)
    x_min = coord_min[0]
    y_min = coord_min[1]
    coord_max = np.amax(coordinates, axis=0)
    x_max = coord_max[0]
    y_max = coord_max[1]
    coord_average = np.sum(coordinates, axis=0) / coordinates.shape[0]
    x_average = coord_average[0]
    y_average = coord_average[1]
    global analysed_dataset; analysed_dataset = {
        &#34;coordinates&#34;: {
            &#34;min_x&#34;: x_min,
            &#34;max_x&#34;: x_max,
            &#34;min_y&#34;: y_min,
            &#34;max_y&#34;: y_max,
            &#34;average_x&#34;: x_average,
            &#34;average_y&#34;: y_average
        },
        &#34;images&#34;: {
            &#34;amount_of_images&#34;: images.shape[0],
            &#34;image_size&#34;: {
                &#34;width&#34;: environ.get(&#34;FULLSIZE_WIDTH&#34;),
                &#34;height&#34;: environ.get(&#34;FULLSIZE_HEIGHT&#34;)
            },
            &#34;thumbnail_size&#34;: {
                &#34;width&#34;: environ.get(&#34;ACTUAL_THUMBNAIL_WIDTH&#34;),
                &#34;height&#34;: environ.get(&#34;ACTUAL_THUMBNAIL_HEIGHT&#34;)
            },    
        }
    }</code></pre>
</details>
</dd>
<dt id="server.api.helper.get_analysed_dataset"><code class="name flex">
<span>def <span class="ident">get_analysed_dataset</span></span>(<span>) ‑> Union[dict, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the values calulated for the dataset</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[dict, None]</code></dt>
<dd>dict containing the values, if anaylse_dataset has been called, None otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_analysed_dataset() -&gt; &#39;Union[dict, None]&#39;:
    &#34;&#34;&#34;Return the values calulated for the dataset

    Returns:
       Union[dict, None]: dict containing the values, if anaylse_dataset has been called, None otherwise
    &#34;&#34;&#34;
    global analysed_dataset
    return analysed_dataset</code></pre>
</details>
</dd>
<dt id="server.api.helper.is_k_valid"><code class="name flex">
<span>def <span class="ident">is_k_valid</span></span>(<span>k: Any, db: Any, id_from_database: bool = False) ‑> Union[Tuple[Literal[True], NoneType, int], Tuple[Literal[False], str, Union[int, NoneType]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a given value for k, k being amount of nearest neighbours to search in a faiss index, is valid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>Any</code></dt>
<dd>amount of desired nearest neighbours. Will be casted as an int, fails if an error occures</dd>
<dt><strong><code>db</code></strong> :&ensp;<code><a title="server.api.db.Database" href="db.html#server.api.db.Database">Database</a></code></dt>
<dd>instance of the database</dd>
<dt><strong><code>id_from_database</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the image to be searched for is already in the database, need to have 0 &lt; k &lt; db.count_documents_in_collection() - 1, </dd>
</dl>
<p>False if different image, need to have 0 &lt; k &lt; db.count_documents_in_collection()</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if successful, False if an error occured</dd>
<dt><code>Union[None, str]</code></dt>
<dd>None if successful, str containing the error message if an error occured</dd>
<dt><code>int</code></dt>
<dd>the (possibly casted) int value for k</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_k_valid(k: Any, db: Any, id_from_database: bool=False) -&gt; &#39;Union[Tuple[Literal[True], None, int], Tuple[Literal[False], str, Union[int, None]]]&#39;:
    &#34;&#34;&#34;Checks if a given value for k, k being amount of nearest neighbours to search in a faiss index, is valid.

    Args:
        k (Any): amount of desired nearest neighbours. Will be casted as an int, fails if an error occures
        db (server.api.db.Database): instance of the database
        id_from_database (bool): if True, the image to be searched for is already in the database, need to have 0 &lt; k &lt; db.count_documents_in_collection() - 1, 
        False if different image, need to have 0 &lt; k &lt; db.count_documents_in_collection()

    Returns:
        bool: True if successful, False if an error occured
        Union[None, str]: None if successful, str containing the error message if an error occured
        int: the (possibly casted) int value for k
    &#34;&#34;&#34;
    if k is None:
        return False, &#34;k is None&#34;, k
    if not type(k) is int:
        try:
            k = int(k)
        except ValueError as e:
            abort(500, message=e)
    if k &lt; 1:
        return False, f&#34;{k} &lt; 1, value too small&#34;, k
    nr_of_files_in_database = db.count_documents_in_collection()
    if id_from_database:
        nr_of_files_in_database -= 1 # excluding the file itself
    if k &gt; nr_of_files_in_database:
        return False, f&#34;k {k} is bigger than the (other) {nr_of_files_in_database} images in the index!&#34;, k
    return True, None, k</code></pre>
</details>
</dd>
<dt id="server.api.helper.load_and_process_one_from_dataset"><code class="name flex">
<span>def <span class="ident">load_and_process_one_from_dataset</span></span>(<span>the_path: str) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the image indicated by the_path and converts it to a flat array</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>the_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>the flat image as an array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_and_process_one_from_dataset(the_path: str) -&gt; np.ndarray:
    &#34;&#34;&#34;Loads the image indicated by the_path and converts it to a flat array

    Args:
        the_path (str): path to the image

    Returns:
        np.ndarray: the flat image as an array
    &#34;&#34;&#34;
    full_path = path.join(environ.get(&#34;DATA_PATH&#34;), the_path)
    resized_image, _ = process_image(full_path)
    return np.array(resized_image, dtype=&#34;float32&#34;)</code></pre>
</details>
</dd>
<dt id="server.api.helper.load_images"><code class="name flex">
<span>def <span class="ident">load_images</span></span>(<span>the_path: str) ‑> Tuple[Union[numpy.ndarray, NoneType], Union[numpy.ndarray, NoneType], Literal[True]]</span>
</code></dt>
<dd>
<div class="desc"><p>Call this function with a the_path to a directory containing images</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>the_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the directory containing the images</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>array of the filenames or None if an error occured</dd>
<dt><code>np.ndarray</code></dt>
<dd>array containing the flat images or None if an error occured</dd>
<dt><code>bool</code></dt>
<dd>True if successful, False if an error occured</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_images(the_path: str) -&gt; &#39;Tuple[Union[np.ndarray, None], Union[np.ndarray, None], Literal[True]]&#39;:
    &#34;&#34;&#34;Call this function with a the_path to a directory containing images

    Args:
        the_path (str): path to the directory containing the images

    Returns:
        np.ndarray: array of the filenames or None if an error occured
        np.ndarray: array containing the flat images or None if an error occured
        bool: True if successful, False if an error occured
    &#34;&#34;&#34;
    names, images, success, correct_shape = _load_images(the_path)
    if success and correct_shape is not None:
        environ[&#34;FULLSIZE_WIDTH&#34;] = str(correct_shape[0])
        environ[&#34;FULLSIZE_HEIGHT&#34;] = str(correct_shape[1])
        return names, images, True
    else:
        return None, None, False</code></pre>
</details>
</dd>
<dt id="server.api.helper.load_images_by_id"><code class="name flex">
<span>def <span class="ident">load_images_by_id</span></span>(<span>ids: list[int], db: Any) ‑> Union[Tuple[Literal[True], np.ndarray, list[dict], None], Tuple[Literal[False], None, None, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Reload all images indicated by ids by getting the path from db</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ids</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>list containing the ids of the images within the database, prechecked</dd>
<dt><strong><code>db</code></strong> :&ensp;<code><a title="server.api.db.Database" href="db.html#server.api.db.Database">Database</a></code></dt>
<dd>instance of the database</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if successful, False if an error occured</dd>
<dt><code>np.ndarray</code></dt>
<dd>flat images or None if an error occured</dd>
<dt><code>list[dict]</code></dt>
<dd>list containing the metadata of the loaded images</dd>
<dt><code>Union[None, str]</code></dt>
<dd>None if successful, str containing the error message if an error occured</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_images_by_id(ids: &#39;list[int]&#39;, db: Any) -&gt; &#39;Union[Tuple[Literal[True], np.ndarray, list[dict], None], Tuple[Literal[False], None, None, str]]&#39;:
    &#34;&#34;&#34;Reload all images indicated by ids by getting the path from db

    Args:
        ids (list[int]): list containing the ids of the images within the database, prechecked
        db (server.api.db.Database): instance of the database

    Returns:
        bool: True if successful, False if an error occured
        np.ndarray: flat images or None if an error occured
        list[dict]: list containing the metadata of the loaded images
        Union[None, str]: None if successful, str containing the error message if an error occured
    &#34;&#34;&#34;
    images = db.get_multiple_by_id(ids, None)
    if images is None:
        return False, None, None, &#34;Error retrieving images from database&#34;
    p_images = []
    all_images = []
    for image in images:
        p_image, _ = process_image(image[&#34;path&#34;])
        p_images.append(p_image)
        all_images.append({
            &#34;id&#34;: image[&#34;id&#34;],
            &#34;filename&#34;: image[&#34;filename&#34;],
            &#34;position&#34;: {
                &#34;x&#34;: image[&#34;x&#34;],
                &#34;y&#34;: image[&#34;y&#34;]
            },
            &#34;cluster_center&#34;: image[&#34;cluster_center&#34;]
        })
    p_images = np.array(p_images, dtype=&#34;float32&#34;)
    return True, p_images, all_images, None</code></pre>
</details>
</dd>
<dt id="server.api.helper.process_image"><code class="name flex">
<span>def <span class="ident">process_image</span></span>(<span>file_path: str) ‑> Tuple[numpy.ndarray, Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an image indicated by its file_path to a flat np.ndarray</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>the flat image</dd>
<dt><code>[int, int]</code></dt>
<dd>width, height of the original image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_image(file_path: str) -&gt; &#39;Tuple[np.ndarray, Tuple[int, int]]&#39;:
    &#34;&#34;&#34;Convert an image indicated by its file_path to a flat np.ndarray

    Args:
        file_path (str): the path of the image

    Returns:
        np.ndarray: the flat image
        [int, int]: width, height of the original image
    &#34;&#34;&#34;
    with Image.open(file_path) as img:
        image_shape = (img.width, img.height)
        converted_image = img.convert(&#34;RGB&#34;)
    resized_image = np.array(converted_image, dtype=&#34;float32&#34;).ravel()
    return resized_image, image_shape</code></pre>
</details>
</dd>
<dt id="server.api.helper.timing"><code class="name flex">
<span>def <span class="ident">timing</span></span>(<span>f: Callable[[Any], Any]) ‑> Callable[[Any, Any], Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Method times the execution of a function, shall be used as a decorator</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>f</code></dt>
<dd>wrapper function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timing(f: &#39;Callable[[Any], Any]&#39;) -&gt; &#39;Callable[[Any, Any], Any]&#39;:
    &#34;&#34;&#34;Method times the execution of a function, shall be used as a decorator

    Returns:
        f: wrapper function
    &#34;&#34;&#34;
    @wraps(f)
    def wrap(*args, **kw) -&gt; Any:
        ts = time()
        result = f(*args, **kw)
        te = time()
        print(f&#34;func:{f.__name__} args:[{args}, {kw}] took: {te-ts:2.4f} sec&#34;)
        return result
    return wrap</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="server.api" href="index.html">server.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="server.api.helper.abort_if_pictures_dont_exist" href="#server.api.helper.abort_if_pictures_dont_exist">abort_if_pictures_dont_exist</a></code></li>
<li><code><a title="server.api.helper.allowed_file" href="#server.api.helper.allowed_file">allowed_file</a></code></li>
<li><code><a title="server.api.helper.analyse_dataset" href="#server.api.helper.analyse_dataset">analyse_dataset</a></code></li>
<li><code><a title="server.api.helper.get_analysed_dataset" href="#server.api.helper.get_analysed_dataset">get_analysed_dataset</a></code></li>
<li><code><a title="server.api.helper.is_k_valid" href="#server.api.helper.is_k_valid">is_k_valid</a></code></li>
<li><code><a title="server.api.helper.load_and_process_one_from_dataset" href="#server.api.helper.load_and_process_one_from_dataset">load_and_process_one_from_dataset</a></code></li>
<li><code><a title="server.api.helper.load_images" href="#server.api.helper.load_images">load_images</a></code></li>
<li><code><a title="server.api.helper.load_images_by_id" href="#server.api.helper.load_images_by_id">load_images_by_id</a></code></li>
<li><code><a title="server.api.helper.process_image" href="#server.api.helper.process_image">process_image</a></code></li>
<li><code><a title="server.api.helper.timing" href="#server.api.helper.timing">timing</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
